# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SplitLine
                                 A QGIS plugin
 Split the line in parts on the basis of user provided distance.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-11
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Ram Kumar K
        email                : ragukulathilak@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon,QIntValidator
from qgis.PyQt.QtWidgets import QAction

from qgis.core import QgsProject, QgsExpressionContextUtils, QgsExpression, QgsExpressionContext, Qgis, QgsRenderContext, QgsGeometry, QgsPoint

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .split_line_dialog import SplitLineDialog
import os.path


class SplitLine:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SplitLine_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Split Line')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SplitLine', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/split_line/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Split Line'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Split Line'),
                action)
            self.iface.removeToolBarIcon(action)




    def splitLine(self,lyr,f,interp): #input layer, feature to be split, interpolation-length
        if self.iface.mapCanvas().mapUnits() == 0:
            mu_interp = interp
        else:
            mu_interp = QgsRenderContext().convertMetersToMapUnits(interp) #convert interpolation length from meters to mapunits
        inter_line_vertex = [] #array of vetrices for split from interpolation
        loop = 1
        while(f.geometry().interpolate(loop*mu_interp).asWkt() != QgsGeometry().asWkt()):
            inter_point = f.geometry().interpolate(loop*mu_interp)
            p=QgsGeometry().fromWkt(inter_point.asWkt())
            disp = 0.000000000001
            inter_point.translate(disp,disp)
            inter_line_vertex.append(QgsPoint(inter_point.asPoint().x(),inter_point.asPoint().y()))
            inter_point.translate(-2*disp, -2*disp)
            inter_line_vertex.append(QgsPoint(inter_point.asPoint().x(),inter_point.asPoint().y()))
            loop += 1
            
        for index in range(0,len(inter_line_vertex)):
            if (index+1)%4==0:
                inter_line_vertex[index-1],inter_line_vertex[index] = inter_line_vertex[index],inter_line_vertex[index-1]

        inter_line = QgsGeometry().fromPolyline(inter_line_vertex)

        return lyr.splitFeatures(inter_line.asPolyline(), True)



    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        line_layers = [layer.name() for layer in QgsProject.instance().mapLayers().values() if layer.geometryType()==1]
        units = ['Meter', 'Kms', 'feet']
        un_successful_ids = []
        featureList = []
        if self.first_start == True:
            self.first_start = False
            self.dlg = SplitLineDialog()
            
        self.dlg.layerDropdown.clear()    
        self.dlg.layerDropdown.addItems(line_layers)
        self.dlg.unitsDropdown.clear()
        self.dlg.unitsDropdown.addItems(units)
        onlyInt = QIntValidator()
        self.dlg.numInput.setValidator(onlyInt)
        self.dlg.radioButtonSelectedFea.setChecked(True)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        print('wait')
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            print('ok')
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            lyr = QgsProject.instance().mapLayersByName(self.dlg.layerDropdown.currentText())[0]
            if not lyr.isEditable():
                lyr.startEditing()
            unit = self.dlg.unitsDropdown.currentText()
            number_input = int(self.dlg.numInput.text())
            unit_oper = {'Meter': number_input, 'Kms': number_input * 1000, 'feet': (number_input * 0.3048)}
            interp = unit_oper[unit]
            selectedFeatures = lyr.selectedFeatures().copy()
            if self.dlg.radioButtonAllFea.isChecked():
                featureList = lyr.getFeatures()
            elif self.dlg.radioButtonSelectedFea.isChecked():
                featureList = selectedFeatures
            for fea in featureList:
                lyr.removeSelection()
                lyr.select(fea.id())
                result = self.splitLine(lyr, fea, interp)
                if result != 0:
                    un_successful_ids.append(fea.id())
            lyr.removeSelection()
            lyr.select([f.id() for f in selectedFeatures])

            lyr_fields = lyr.fields().names()
            expression = QgsExpression('$length')
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(lyr))
            if 'new_length' in lyr_fields: 
                for fea in lyr.getFeatures():
                    context.setFeature(fea)
                    fea['new_length'] = expression.evaluate(context)
                    lyr.updateFeature(fea)
            
            if len(un_successful_ids):#unsuccessful
                self.iface.messageBar().pushMessage(f'Unsuccessfull, features are {un_successful_ids}', level = Qgis.Critical, duration = 10)
                return f'Unsuccessful, features are {un_successful_ids}'
            self.iface.messageBar().pushMessage(f'Operation completed successfully', level = 3, duration = 10)
            
            return 'Operation completed successfully'
